快排是一个就地排序算法。由英国计算机科学家 Tony Hoare 在1959发明，于1962年进行发表。目前它仍然是广泛应用的排序算法。如果实现的算法比较优秀，那么会比归并排序快一些，比堆排序快2-3倍。

> 就地算法（ in-place algorithm，也称“原地算法”）是基本上不需要借助额外的数据结构就能对输入的数据进行变换的算法。 不过，分配少量空间给部分辅助变量是被允许的。 算法执行过程中，输入的数据往往会被输出结果覆盖。 原地算法只能通过替换或交换元素的方式来修改原始的输入。

快排是一种分治算法。通过在数组中选取一个`支点（pivot）`元素，然后根据其他数据元素是否大于或者小于支点元素来将其他的元素分成两个子数组。由于这个原因，有时候会称之为分区交换排序（partition-exchange sort）.接下来子数组按照这个逻辑进行递归排序。这就可以实现就地完成，只需要少量内存来执行排序算法。

快速排序是一种比较排序，这意味着它可以对定义了 “less-than” 关系的任何类型的项目进行排序。快速排序的有效实现不是稳定的排序，这意味着不保留相等排序项的相对顺序。

> 如果队列中存在两个相等的数字排序过程中 这两个数字的先后顺序如果不会发生变化 就叫做稳定的排序反之叫做不稳定排序

快排的数学分析表明，平均而言，在对 n 条数据进行排序的情况下，负责度为 : O(n log n)，在最坏情况下 O(n2).

如下为快排的一个动画展示：

![Sorting_quicksort_anim](C:\Users\lixiaobao14\IdeaProjects\AlgorithmicAndDataStructure\doc\image\Sorting_quicksort_anim.gif)

## 历史背景

快速排序算法是由 Tony Hoare 于 1959 年在莫斯科国立大学做访问学者时发明的。当时，Hoare 正在为国家物理实验室从事机器翻译项目。作为翻译过程的一部分，他需要先对俄语句子中的单词进行排序，然后再在磁带上按字母顺序查找俄英词典。 在意识到他的第一个想用的插入排序会很慢后，他想出了一个新想法。他用 Mercury Autocode 编写了分区部分，但在处理未排序的段列表时遇到了麻烦。回到英国后，他被要求为 Shellsort 编写代码。 Hoare 向他的老板提到他知道一种更快的算法，而他的老板下注 6 便士赌他不能拿出来更好的算法。最后，他的老板承认他赌输了。后来，Hoare 了解了 ALGOL 及其进行递归的能力，这使他能够在当时主要的计算机科学期刊“计算机通信协会（*[Communications of the Association for Computing Machinery](https://en.wikipedia.org/wiki/Communications_of_the_ACM)*）”上发表代码。

Quicksort 获得了广泛的采用，例如，在 Unix 中作为默认库排序子程序出现。因此，它把它的名字借给了 C 标准库子程序 qsort和 Java 的参考实现。

Robert Sedgewick 于 1975 年的博士论文被认为是 Quicksort 研究的里程碑，他解决了许多与分析各种`支点(pivot)`选择方案相关的开放性问题，包括 Samplesort、Van Emden 的自适应分区以及预期比较次数的推导和数据交换。 Jon Bentley 和 Doug McIlroy 结合其他的变成库进行了各种改进。 Bentley 在他的《Programming Pearls》一书中描述了另一种更简单紧凑的分区方案，他将其归功于 Nico Lomuto。后来 Bentley 写道，他使用 Hoare 的版本多年，但从未真正理解它，但 Lomuto 的版本很简单，足以证明是正确的。 Bentley 在同一篇文章中将 Quicksort 描述为 “我写过的最漂亮的代码”。 Lomuto  的分区方案也被教科书《算法导论》普及，尽管它不如 Hoare 的方案，因为它平均进行三倍多的交换，并且在所有元素都相等时降级为 O(n2) 运行时间。

2009 年，弗拉基米尔·雅罗斯拉夫斯基  ( Vladimir Yaroslavskiy )  提出了一种使用两个`pivot`而不是一个`pivot`的新快速排序实现。 在 Java 核心库邮件列表中，他发起了一场讨论，声称他的新算法优于运行时库的排序方法，当时该方法基于 Bentley 和 McIlroy 广泛使用和精心调整的经典 Quicksort 变体[。 Yaroslavskiy 的 Quicksort 已被选为 Oracle 的 Java 7 运行时库 中新的默认排序算法而且经过广泛的实证性能测试。

## 算法原理

快速排序是一种基于分区例程对数组进行排序的分治算法；这种分区的细节可能有所不同，因此 quicksort 实际上是一系列密切相关的算法。应用于至少两个元素的范围，分区产生分成两个连续的非空子范围的划分，以这样的方式，第一子范围的任何元素都不大于第二子范围的任何元素。应用此分区后，快速排序然后递归地对子范围进行排序，可能是在从子范围中排除位于分区点的元素之后，此时已知该元素已位于其最终位置。由于其递归性质，必须对快速排序（如分区例程）进行公式化，以便能够在较大数组中的某个范围内调用，即使最终目标是对完整数组进行排序。就地快速排序的步骤包括：

如果范围少于两个元素，请立即返回，因为无需执行任何操作。对于其他很短的长度，可能会应用一种特殊用途的排序方法，并跳过这些步骤的其余部分。

否则，选择一个在范围内出现的值，称为pivot（精确的选择方式取决于分区例程，并且可能涉及随机性）。

划分范围：在确定划分点的同时，对其元素进行重新排序，使值小于轴的所有元素位于划分之前，而值大于轴的所有元素位于划分之后；与轴相等的元素可以向任意方向移动。由于至少存在一个轴实例，大多数分区例程都确保在分割点结束的值等于轴，并且现在处于其最终位置（但快速排序的终止并不依赖于此，只要生成的子范围严格小于原始范围）。

递归地将快速排序应用于分区点之前的子范围和分区点之后的子范围，可能会从这两个范围中排除与分区点处的轴相等的元素。（如果分区在边界附近产生一个可能更大的子范围，已知所有元素都等于轴，则也可以排除这些子范围。）

分区例程的选择（包括轴选择）和上面未完全指定的其他细节可能会影响算法的性能，可能在很大程度上影响特定输入数组的性能。因此，在讨论快速排序的效率时，有必要首先指定这些选项。这里我们提到两种特定的分区方法。
